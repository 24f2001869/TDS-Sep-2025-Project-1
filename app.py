import os
import threading
import base64
import subprocess
import time
import requests
import shutil
from flask import Flask, request, jsonify
from dotenv import load_dotenv
import google.generativeai as genai

# --- CONFIGURATION ---
# Load environment variables from .env file for local development
load_dotenv()

# Initialize Flask app
app = Flask(__name__)

# Configure Google Gemini API
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

# --- HELPER FUNCTIONS ---

def get_env_variable(var_name):
    """Gets an environment variable or raises an error if it's not found."""
    value = os.getenv(var_name)
    if not value:
        raise ValueError(f"FATAL ERROR: Environment variable '{var_name}' is not set.")
    return value

def generate_llm_code(brief, existing_code=None):
    """
    Generates code using the LLM. For round 2, it includes existing code for context.
    """
    print("üß† Asking LLM to generate code...")
    model = genai.GenerativeModel('models/gemini-pro-latest')

    if existing_code:
        # Prompt for modifying existing code (Round 2)
        prompt = f"""
        You are an expert web developer. You need to modify an existing HTML file.
        The user wants to add the following features or changes: "{brief}"

        Here is the existing code for `index.html`:
        --- EXISTING CODE ---
        {existing_code}
        --- END EXISTING CODE ---

        Please provide the full, complete, and updated code for `index.html` that incorporates the requested changes.
        Do not include any explanations, comments, or any text other than the raw, updated HTML code.
        """
    else:
        # Prompt for creating new code from scratch (Round 1)
        prompt = f"""
        You are an expert web developer. Based on the following brief, generate a single, self-contained HTML file named index.html.
        The file must contain all necessary HTML, CSS, and JavaScript.
        Do not include any explanations, comments, or any text other than the raw code for the file.

        BRIEF: "{brief}"
        """

    response = model.generate_content(prompt)
    print("üí° LLM responded.")
    # Clean up the response to remove markdown formatting
    return response.text.replace("```html", "").replace("```", "").strip()

def generate_readme(task_data):
    """Generates a professional README.md file content."""
    return f"""
# Project: {task_data.get('task')}

## üìú Summary
This project was automatically generated and deployed by an AI-powered system as part of the IITM BS Tools in Data Science course.
The application brief was: "{task_data.get('brief')}"

## ‚öôÔ∏è Setup & Usage
This is a static web page deployed on GitHub Pages. No special setup is required to view it.
The page can be accessed at the deployed GitHub Pages URL.

## ü§ñ Code Explanation
The `index.html` file is a self-contained application generated by a Large Language Model (LLM). It includes all necessary HTML for structure, CSS for styling, and JavaScript for functionality.
Any additional files (like `.csv` or `.json`) are static assets used by the main script.

## üìÑ License
This project is licensed under the MIT License. See the `LICENSE` file for details.
"""

def notify_evaluation_server(payload):
    """Sends the final results to the evaluation server with retry logic."""
    url = payload.pop("evaluation_url") # Extract URL and remove from payload
    print(f"üì£ Notifying evaluation server at {url}...")

    delays = [1, 2, 4, 8] # Exponential backoff delays in seconds
    for i, delay in enumerate(delays):
        try:
            response = requests.post(url, json=payload, timeout=15)
            if response.status_code == 200:
                print("‚úÖ Notification successful!")
                return True
            else:
                print(f"‚ö†Ô∏è Notification failed with status {response.status_code}. Retrying...")
        except requests.RequestException as e:
            print(f"üö® Notification request failed: {e}. Retrying...")

        if i < len(delays) - 1:
            time.sleep(delay)

    print("‚ùå All notification attempts failed.")
    return False

# --- CORE LOGIC: BACKGROUND TASK ---

def background_task(task_data):
    """The main function that runs in a background thread."""
    print(f"ü§ñ Starting background job for task: {task_data.get('task')}, Round: {task_data.get('round')}")

    try:
        # Load secrets safely within the thread
        MY_SECRET = get_env_variable("MY_SECRET")
        GITHUB_USERNAME = get_env_variable("GITHUB_USERNAME")
        GITHUB_TOKEN = get_env_variable("GITHUB_TOKEN")

        # 1. Verify Secret
        if task_data.get("secret") != MY_SECRET:
            print("‚ùå Secret mismatch. Aborting task.")
            return

        # --- Define Repo Details ---
        repo_name = f"tds-proj-{task_data.get('task')}"
        repo_url = f"https://github.com/{GITHUB_USERNAME}/{repo_name}"
        local_repo_path = os.path.join(os.getcwd(), repo_name)

        # --- Round-Specific Logic ---
        if task_data.get("round") == 1:
            # Round 1: Create a new repository
            print("--- Starting Round 1: Create Repo ---")

            # Clean up any previous local folder
            if os.path.exists(local_repo_path):
                shutil.rmtree(local_repo_path)

            os.makedirs(local_repo_path)

            # Generate code and files
            html_code = generate_llm_code(task_data.get("brief"))
            readme_content = generate_readme(task_data)
            license_content = "MIT License\n\nCopyright (c) 2025 Your Name\n\n..." # Add full MIT License text

            with open(os.path.join(local_repo_path, "index.html"), "w", encoding="utf-8") as f:
                f.write(html_code)
            with open(os.path.join(local_repo_path, "README.md"), "w", encoding="utf-8") as f:
                f.write(readme_content)
            with open(os.path.join(local_repo_path, "LICENSE"), "w", encoding="utf-8") as f:
                f.write(license_content)

            # Handle attachments
            for attachment in task_data.get("attachments", []):
                file_content_b64 = attachment['url'].split(',')[1]
                file_content = base64.b64decode(file_content_b64).decode('utf-8')
                with open(os.path.join(local_repo_path, attachment['name']), "w", encoding="utf-8") as f:
                    f.write(file_content)

            # GitHub commands for creation
            # GitHub commands for creation
            # GitHub commands for creation
            commands = [
                'git config --global user.name "24f2001869"',
                'git config --global user.email "24f2001869@ds.study.iitm.ac.in"',
                "git config --global init.defaultBranch main",
                "git init",
                "git add .",
                'git commit -m "feat: Initial commit for round 1"',
                f"gh repo create {repo_name} --public",
                f"git remote add origin https://{GITHUB_USERNAME}:{GITHUB_TOKEN}@github.com/{GITHUB_USERNAME}/{repo_name}.git",
                "git push -u origin main",
                f'curl -L -X POST -H "Accept: application/vnd.github+json" -H "Authorization: Bearer {GITHUB_TOKEN}" -H "X-GitHub-Api-Version: 2022-11-28" https://api.github.com/repos/{GITHUB_USERNAME}/{repo_name}/pages -d \'{{"source":{{"branch":"main","path":"/"}}}}\''
            ]

        else: # Round 2 or greater
            # Round 2: Update existing repository
            print("--- Starting Round 2: Update Repo ---")

            # Clean up and clone the existing repo
            if os.path.exists(local_repo_path):
                shutil.rmtree(local_repo_path)
            subprocess.run(f"gh repo clone {repo_url} {local_repo_path}", shell=True, check=True)

            # Read existing code to provide context to LLM
            with open(os.path.join(local_repo_path, "index.html"), "r", encoding="utf-8") as f:
                existing_html = f.read()

            # Generate updated code and README
            updated_html_code = generate_llm_code(task_data.get("brief"), existing_code=existing_html)
            updated_readme_content = generate_readme(task_data)

            with open(os.path.join(local_repo_path, "index.html"), "w", encoding="utf-8") as f:
                f.write(updated_html_code)
            with open(os.path.join(local_repo_path, "README.md"), "w", encoding="utf-8") as f:
                f.write(updated_readme_content)

            # GitHub commands for update
            commands = [
                "git add .",
                f'git commit -m "feat: Update for round {task_data.get("round")}"',
                "git push"
            ]

        # Execute GitHub commands
        for command in commands:
            print(f"  > Executing: {command}")
            subprocess.run(command, shell=True, check=True, cwd=local_repo_path)

        # Get commit SHA
        commit_sha = subprocess.check_output(["git", "rev-parse", "HEAD"], cwd=local_repo_path).decode("utf-8").strip()
        pages_url = f"https://{GITHUB_USERNAME}.github.io/{repo_name}/"

        print("‚úÖ GitHub operations complete.")
        print(f"  - Repo URL: {repo_url}")
        print(f"  - Pages URL: {pages_url}")
        print(f"  - Commit SHA: {commit_sha}")

        # Prepare payload for notification server
        notification_payload = {
            "email": task_data.get("email"),
            "task": task_data.get("task"),
            "round": task_data.get("round"),
            "nonce": task_data.get("nonce"),
            "repo_url": repo_url,
            "commit_sha": commit_sha,
            "pages_url": pages_url,
            "evaluation_url": task_data.get("evaluation_url") # Will be removed by the function
        }

        # Send notification
        notify_evaluation_server(notification_payload)

        # Clean up the local repository folder
        shutil.rmtree(local_repo_path)

    except Exception as e:
        print(f"‚ùå‚ùå‚ùå An error occurred in the background task: {e}")

# --- FLASK API ENDPOINT ---

@app.route('/api-endpoint', methods=['POST'])
def handle_request():
    """Handles incoming requests from the evaluation server."""
    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400

    data = request.json
    print("üöÄ Request received!")

    # Start the background task in a new thread
    thread = threading.Thread(target=background_task, args=(data,))
    thread.start()

    # Immediately respond with the required JSON
    return jsonify({"usercode": data.get("email")}), 200

# --- MAIN EXECUTION ---

if __name__ == '__main__':
    app.run(port=8080, debug=True)
